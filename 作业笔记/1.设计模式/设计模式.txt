一、单例模式
单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。
ServletContext、 ServletConfig、ApplicationContext、DBPool
隐藏其所有的构造方法。构造方法私有化。
属于创建型模式。

优点：
在内存中只有一个实例，减少了内存开销
可以避免对资源的多重占用
设置全局访问点，严格控制访问

缺点：
没有接口，扩展困难
如果要扩展单例对象，只有修改代码，没有其他途径

常见写法：
1.饿汉式单例
demo --> sigleton.HungrySingleton/sigleton.HungryStaticSingleton
优点：执行效率高，性能高，没有任何的锁
缺点：某些情况下，可能会造成内存浪费

2.懒汉式单例
demo --> sigleton.LazzySingleton/sigleton.LazzyDoubleCheckSingleton

3.注册式单例
4.ThreadLocal单例


总结：
1.私有化构造器
2.保证线程安全
3.延迟加载
4.防止序列化和反序列化破坏单例
5.防御反射攻击单例

二、原型模式

原型模式是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数，属于创建型模式。

原型模式适用的场景：
1.类初始化消耗资源较多
2.new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
3.构造函数比较复杂
4.循环体中生产大对象时

原型模式的优点：
性能优良，Java自带的，原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了许多。
可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建过程。

原型模式的缺点：
必须配备克隆（或者可拷贝）方法
当对已有类进行改造的时候，需要修改代码，违反了开闭原则。
深拷贝、浅拷贝需要运用得当


三、建造者模式
建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建可以使用不同的构建方式。
QueryWarapper...

建造者模式的适用场景：
适用于创建对象需要很多步骤，但是步骤的顺序不一定固定
如果一个对象有非常复杂的内部结构（很多属性）
把复杂对象的创建和使用分离

应用：
StringBilder.append()
mybatis -- CacheBuilder
SqlSessionFactoryBuilder
spring -- BeanDefinitionBuilder

总结：
优点：封装性好，创建和使用分离，扩展性好，建造类之间独立，一定程度上解耦
缺点：产生多余的builder对象，产品内部发生变化，建造者都要修改，成本较大


建造者模式和工厂模式的区别
1.建造者模式更加注重方法的调用顺序，工厂模式注重于创建对象
2.创建对象的粒度不同，建造者创建复杂的对象，由各种复杂的部件组成，工程模式创建出来的都一样
3.关注点：工厂模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成
4.建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样


四、代理模式
代理模式是指为其他对象提供的一种代理，以控制对这个对象的访问。
代理对象在客服端和目标对象之间起到中介作用，属于结构型设计模式。


静态代理：显示声明被代理对象
动态代理：
