七大设计原则：
1、开闭原则，对扩展开放，对修改关闭，减少维护带来的风险
2、依赖倒置原则，高层不应该依赖低层，更利于代码结构的升级扩展
3、单一职责原则，一个类只干一件事，便于理解，提高代码可读性
4、接口隔离原则，一个接口只干一个事，功能解耦，高聚合，低耦合
5、迪米特法则，不该知道的不要知道，之和朋友交流，不和陌生人说话，减少代码臃肿
6、里氏替换原则，子类重写方法功能发生改变，不应该影响父类方法的含义，防止继承泛滥
7、合成复用原则，尽量使用组合实现代码复用，而不使用继承，降低代码耦合

=======================================================================================================================
哪些情况可能会破坏单例
1.多线程
解决方案：
1.静态内部类
2.双重检查锁写法

2.JVM指令重排序
解决方案：加volatile关键字

3.深克隆，每次都会重新创建新的实例
解决方案：在单例对象中重写clone()方法

4.反序列化对象会重新分配内存，相当于重新创建对象
解决方案：重写readResolve()方法

5.反射可以任意调用私有构造方法创建单例对象
解决方案：
1.在构造方法中检查单例对象，如果已经创建则抛出异常
2.将单例的实现改为枚举式单例

单例使用选择：
如果程序不是太复杂，单例对象又不多，推荐使用饿汉式单例
如果经常发生多线程并发情况，推荐使用静态内部类和枚举式单例
=======================================================================================================================
原型模式，指原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象

深克隆和浅克隆
区别：
1.数据拷贝后两者之间是否有关联
2.改变一个值是否会影响到另外一个数值变化
浅克隆：BeanUtils和PropertyUtils、实现Cloneable接口、Arrays.copyOf，但是在ArrayList中实现了深克隆的
深克隆：
    每个对象都要实现Cloneable接口并重写Object类中的clone方法、序列化，
    必须实现Serializable
    SerializationUtils.clone()
    JSON

=======================================================================================================================
建造者模式
将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示

链式编程是建造者模式的标配吗？
NO 只是为了使用更加方便，融入了链式编程

=======================================================================================================================
代理模式
为其他对象提供一种代理，以控制对这个对象的访问

如何理解静态代理和动态代理
静态代理：一个代理只能服务一种类型的对象，当有N个业务时，需要N个代理，不利于业务扩展
动态代理：一个代理类可以服务于所有的业务对象

动态代理的基本实现：
1.拿到被代理类的引用，并且获取它的所有接口
2.JDK Proxy类重新生成一个新的类，实现了被代理类所有接口的方法
3.动态生成Java代码，把增强逻辑加入到新生成的代码中
4.编译生成新的java代码的class文件
5.加载并重新运行新的class得到的类就是全新类

CGLib和JDK动态代理的对比
1.JDK实现被代理对象的接口，CGLib继承被代理对象
2.都是在运行时生成字节码
3.JDK通过反射，CGLib通过FastClass机制
4.CGLib无法代理final修饰的方法


=======================================================================================================================
策略模式
将定义的算法家族分别封装起来，让他们之间可以相互替换，从而让算法的变化不会影响到用户的使用

什么场景下应该用策略模式，什么场景下不该用？
适合使用的场景：需要经常自由切换执行逻辑和规则的场景
不适合的场景：如果两种逻辑之间关联性本来就非常大，而且变化也非常快


=======================================================================================================================
责任链模式
将链中每一个节点都看做一个对象，每个节点处理的请求均不同，且内部自动维护下一个节点对象，
当一个请求从链式的手段发出时，会沿着责任链预设的路径一次传递到每一个节点对象，知道被链中的某个对象处理为止

将处理不同逻辑对象连接成一个链表结构，每个对象都保存下一个节点

责任链模式的实现原理？
单项链表上下文
优点：
1.将请求解耦
2.请求处理者只需要关注自己感兴趣的请求进行处理即可，对应不感兴趣的请求，直接转发给下一级节点对象
3.具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果
4.链路结构灵活，可以通过改变链路结构动态的新增或删减责任
5.易于扩展新的请求处理类，符合开闭原则

缺点：
1.责任链太长或者处理时间过长，会影响整体性能
2.如果节点对象存在循环引用时，会造成死循环，导致系统崩溃
=======================================================================================================================

设计模式的分类：
1.创建型 类的创建
2.结构型 组合替代，类与类之间的关系
3.行为型 关注对象与行为的分离、就是要把行为分离到类里面

一句话总结设计模式：
工厂模式：产品标准化，生产更高效，封装创建细节，LoggerFactory/BeanFactory
单例模式：保证独一无二，Calender/Runtime
原型模式：拔一根猴毛，吹出千万个，高效创建对象，ArrayList/PrototypeBean
建造者模式：高配中配与低配，想选哪配就哪配。StringBuilder/BeanDefinitionBuilder
代理模式：没有资源没时间，得找媒婆来帮忙。增强职责。ProxyFactoryBean/jdkDynmicAopProxy
门面模式：打开一扇门，走向全世界。统一访问入口。JdbcUtils
装饰器模式：他大舅他二舅，都是他舅。灵活扩展，同宗同源。BufferedReader
享元模式：优化资源配置，减少重复浪费。共享资源池。String/ObjectPool
组合模式：人在一起叫团伙，心在一起叫团队。统一整体和个体。HashMap/SqlNode
适配器模式：适合自己的，才是最好的。兼容转换，求同存异。AdvisorAdapter/HandlerAdapter
桥接模式：约定优于配置，不允许使用继承。DriverManager
委派模式：这个需求很简单，怎么实现我不管。只对结果负责。ClassLoader
模板模式：流程全部标准化，需要微调请覆盖。逻辑复用。JdbcTemplate
策略模式：条条大路通罗马，具体哪条你来定。把选择交给用户。Comparator/InstantiationStrategy
迭代器模式：流水线上坐一天，每个包裹扫一遍。统一对集合的访问方式。Iterator
命令模式：运筹帷幄之中，决胜千里之外。解耦请求和处理。Runnable/TestCase
状态模式：状态驱动行为，行为决定状态。绑定状态和行为，比如订单状态跟踪。Lifecycle
备忘录：备份，StateManageableMessageContext
中介者：联系方式我刚给你，怎么搞定我不管。统一管理网状资源。朋友圈。Timer
解耦器模式：我想说方言，，一切解释权归我所有，实现特定语法解析。Pattern、ExpressionParse
观察者模式：到点就通知我，解耦观察者与被观察者。闹钟。ContextLoaderListener
访问者模式：横看成岭侧成峰，远景高低各不同。解耦数据结构和数据操作。FileVisitor

XX模式 VS XX模式
1.策略模式VS委派模式
共同点：都属于行为型模式
不同点：策略模式关注于能否相互替换，委派模式关注分发和调度的过程
关联：都有切换的上下文

2.工厂模式VS抽象工厂模式
共同点：都属于创建型模式，职责相同，都是创建对象
不同点：创建出来的产品扩展程度不一样，工厂方法是单维度扩展，抽象工厂可以实现多维度拓展
关联：工厂方法很多情况下会作为抽象工厂的子类

3.中介者模式VS桥接模式
共同点：都具备将两个对象建立联系
不同点：行为型VS结构型，中介者将多维度网状结构的对象建立联系，桥接是将两个维度（抽象和具象）
关联：中介者可已看作是更复杂的桥接

4.委派模式VS代理模式
共同点：都有保护目标对象的特性
不同点：行为型VS结构型；职责不同，委派模式不对目标类的功能做增强

