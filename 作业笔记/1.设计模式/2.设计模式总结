七大设计原则：
1、开闭原则，对扩展开放，对修改关闭，减少维护带来的风险
2、依赖倒置原则，高层不应该依赖低层，更利于代码结构的升级扩展
3、单一职责原则，一个类只干一件事，便于理解，提高代码可读性
4、接口隔离原则，一个接口只干一个事，功能解耦，高聚合，低耦合
5、迪米特法则，不该知道的不要知道，之和朋友交流，不和陌生人说话，减少代码臃肿
6、里氏替换原则，子类重写方法功能发生改变，不应该影响父类方法的含义，防止继承泛滥
7、合成复用原则，尽量使用组合实现代码复用，而不使用继承，降低代码耦合

设计模式的分类：
1.创建型 类的创建
2.结构型 组合替代，类与类之间的关系
3.行为型 关注对象与行为的分离、就是要把行为分离到类里面

一句话总结设计模式：
工厂模式：产品标准化，生产更高效，封装创建细节，LoggerFactory/BeanFactory
单例模式：保证独一无二，Calender/Runtime
原型模式：拔一根猴毛，吹出千万个，高效创建对象，ArrayList/PrototypeBean
建造者模式：高配中配与低配，想选哪配就哪配。StringBuilder/BeanDefinitionBuilder
代理模式：没有资源没时间，得找媒婆来帮忙。增强职责。ProxyFactoryBean/jdkDynmicAopProxy
门面模式：打开一扇门，走向全世界。统一访问入口。JdbcUtils
装饰器模式：他大舅他二舅，都是他舅。灵活扩展，同宗同源。BufferedReader
享元模式：优化资源配置，减少重复浪费。共享资源池。String/ObjectPool
组合模式：人在一起叫团伙，心在一起叫团队。统一整体和个体。HashMap/SqlNode
适配器模式：适合自己的，才是最好的。兼容转换，求同存异。AdvisorAdapter/HandlerAdapter
桥接模式：约定优于配置，不允许使用继承。DriverManager
委派模式：这个需求很简单，怎么实现我不管。只对结果负责。ClassLoader
模板模式：流程全部标准化，需要微调请覆盖。逻辑复用。JdbcTemplate
策略模式：条条大路通罗马，具体哪条你来定。把选择交给用户。Comparator/InstantiationStrategy
迭代器模式：流水线上坐一天，每个包裹扫一遍。统一对集合的访问方式。Iterator
命令模式：运筹帷幄之中，决胜千里之外。解耦请求和处理。Runnable/TestCase
状态模式：状态驱动行为，行为决定状态。绑定状态和行为，比如订单状态跟踪。Lifecycle
备忘录：备份，StateManageableMessageContext
中介者：联系方式我刚给你，怎么搞定我不管。统一管理网状资源。朋友圈。Timer
解耦器模式：我想说方言，，一切解释权归我所有，实现特定语法解析。Pattern、ExpressionParse
观察者模式：到点就通知我，解耦观察者与被观察者。闹钟。ContextLoaderListener
访问者模式：横看成岭侧成峰，远景高低各不同。解耦数据结构和数据操作。FileVisitor

XX模式 VS XX模式
1.策略模式VS委派模式
共同点：都属于行为型模式
不同点：策略模式关注于能否相互替换，委派模式关注分发和调度的过程
关联：都有切换的上下文

2.工厂模式VS抽象工厂模式
共同点：都属于创建型模式，职责相同，都是创建对象
不同点：创建出来的产品扩展程度不一样，工厂方法是单维度扩展，抽象工厂可以实现多维度拓展
关联：工厂方法很多情况下会作为抽象工厂的子类

3.中介者模式VS桥接模式
共同点：都具备将两个对象建立联系
不同点：行为型VS结构型，中介者将多维度网状结构的对象建立联系，桥接是将两个维度（抽象和具象）
关联：中介者可已看作是更复杂的桥接

4.委派模式VS代理模式
共同点：都有保护目标对象的特性
不同点：行为型VS结构型；职责不同，委派模式不对目标类的功能做增强

